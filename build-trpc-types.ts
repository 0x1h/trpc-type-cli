import fs from "fs";
import path from "path";
import { Project, SourceFile, TypeAliasDeclaration } from "ts-morph";
import { z } from "zod";
import configFile from "./trpc-types-cli.config";
import url from "url";

const ConfigSchema = z.object({
  routerFile: z.string(),
  outputFile: z.string(),
  includePaths: z.array(z.string()).optional(),
  excludePaths: z.array(z.string()).optional(),
  baseUrl: z.string().optional(),
  generateClient: z.boolean().optional(),
});

type Config = z.infer<typeof ConfigSchema>;

class TRPCTypesGenerator {
  private project: Project;
  private config: Config;

  constructor(configPath: string) {
    this.config = ConfigSchema.parse(configFile);

    // Initialize ts-morph project
    this.project = new Project({
      tsConfigFilePath: path.resolve(process.cwd(), "tsconfig.json"),
      skipAddingFilesFromTsConfig: true,
    });
  }

  private findAppRouter(
    sourceFile: SourceFile
  ): TypeAliasDeclaration | undefined {
    return sourceFile
      .getTypeAliases()
      .find(
        (type) =>
          type.getName() === "AppRouter" || type.getName()?.includes("Router")
      );
  }

  private generateTypeDefinitions(): string {
    const routerFile = this.project.addSourceFileAtPath(
      path.resolve(process.cwd(), this.config.routerFile)
    );

    const appRouter = this.findAppRouter(routerFile);
    if (!appRouter) {
      throw new Error(
        "Could not find AppRouter type in the specified router file"
      );
    }

    let output = "// ✨ Generated by trpc-types-cli\n\n";

    output += `import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\n\n`;

    output += `export type AppRouter = ${appRouter
      .getType()
      .getText(appRouter)};\n\n`;

    output += `export type RouterInputs = inferRouterInputs<AppRouter>;\n`;
    output += `export type RouterOutputs = inferRouterOutputs<AppRouter>;\n`;

    if (this.config.generateClient) {
      output += `
export type RouterProcedures = AppRouter['_def']['procedures'];

export type ProcedureNames<T extends RouterProcedures> = {
  [K in keyof T]: T[K] extends RouterProcedures ? ProcedureNames<T[K]> : K;
}[keyof T];
`;
    }

    return output;
  }

  public async generate(): Promise<void> {
    try {
      const outputPath = path.resolve(process.cwd(), this.config.outputFile);
      const typeDefinitions = this.generateTypeDefinitions();

      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      fs.writeFileSync(outputPath, typeDefinitions);
      console.log(
        `✨ Successfully generated types at ${this.config.outputFile}`
      );
    } catch (error) {
      console.error("Error generating types:", error);
      process.exit(1);
    }
  }
}

if (import.meta.url === url.pathToFileURL(process.argv[1]!).href) {
  const configPath = process.argv[2] || "./trpc-types-cli.config.ts";

  const loadConfig = async () => {
    try {
      const configModule = await import(
        url.pathToFileURL(path.resolve(process.cwd(), configPath)).href
      );

      const config = configModule.default || configModule;
      const generator = new TRPCTypesGenerator(config);
      await generator.generate();
    } catch (error) {
      console.error("Error loading configuration:", error);
      process.exit(1);
    }
  };

  loadConfig();
}

export { TRPCTypesGenerator, type Config };
